<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>杨家锋的博客</title>
</head>
<link rel="stylesheet" href="../static/styles/prism-xonokai.css"/>
<link rel="stylesheet" href="../static/styles/base.css">
<link rel="stylesheet" href="../static/styles/article.css">
</head>
<body>
  {{template "header"}}
  
  <div class="container">
    <div class="article">
      <h1>什么是SSH? 了解加密、端口和连接</h1>
      <img src="/static/images/ssh3.png" alt="">
      <p>
        简单说，SSH是一种网络协议，用于计算机之间的加密登录。

如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。

最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。

需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。

此外，本文只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，这需要另文介绍。
      </p>
      <img src="/static/images/ssh.png" alt="ssh">
      <p>
        与之相对的是 CSR（Client Side Render），是一种目前流行的渲染方式，它依赖的是运行在客户端的JS，用户首次发送请求只能得到小部分的指引性HTML代码。第二次请求将会请求更多包含HTML字符串的JS文件。
      </p>
      <pre class="line-numbers language-javascript"><code>
      const express = require('express')
      const app = express()
      const port = 9527
      
      app.use(express.static('pages'))
      app.listen(port, () => {
        console.log(`Example app listening on port ${port}`)
      })
      
      </code></pre>
      <p>
        为什么需要 SSR ？
    目前前端流行的框架大都是适用于构建 SPA（单页面应用程序），在SPA这个模型中，是通过动态地重写页面的部分与用户交互，而避免了过多的数据交换，响应速度自然相对更高。
    
    但是，SPA应用的首屏打开速度一般都很慢，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后再渲染页面，并且 SPA 应用不利于 SEO 优化。
    
    这时候，人们想着是不是可以将应用首页先加载出来，然后让首页用不到的其他 JS 文件再慢慢加载。但是由于 JS 引擎是单线程的，数据的组装过程会受到阻塞，单靠浏览器端的话不容易实现。
    
    SSR 重新焕发活力的契机就在于此，如果将组装数据、渲染 HTML 页面的过程放在服务端，而浏览器端只负责显示接收到的 HTML 文件，那首屏的打开速度无疑会快很多。
      </p>
    
    <pre class="language-javascript"><code>
    // token.ts
    export type LiteralType = string;
    export type Token = {
      type: TokenType;
      literal: LiteralType;
    };
    export const enum TokenType {
      ILLEGAL = 'ILLEGAL',
      EOF = 'EOF',
    
      // Identifiers + Literals
      IDENT = 'IDENT',
      INT = 'INT',
    
      // Operators
      ASSIGN = '=',
      PLUS = '+',
      MINUS = '-',
      BANG = '!',
      ASTERISK = '*',
      SLASH = '/',
    
      LT = '<',
      GT = '>',
    
      EQ = '==',
      NOT_EQ = '!=',
    
      // Delimiters
      COMMA = ',',
      SEMICOLON = ';',
    
      LPAREN = '(',
      RPAREN = ')',
      LBRACE = '{',
      RBRACE = '}',
    
      // Keywords
      FUNCTION = 'FUNCTION',
      LET = 'LET',
      TRUE = 'TRUE',
      FALSE = 'FALSE',
      IF = 'IF',
      ELSE = 'ELSE',
      RETURN = 'RETURN',
    }
    
    </code></pre>
    </div>
    </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/prism.min.js"> </script>
</body>
</html>